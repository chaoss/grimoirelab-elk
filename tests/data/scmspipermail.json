[{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "ART_HACKPDF 1.4 transparency",
    "data": {
        "Date": "Mon, 24 Jul 2000 14:35:53 -0700",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Raph Levien <raph@acm.org>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "Message-ID": "<200007242135.OAA17491@lizardbreath.artofcode.com>",
        "Precedence": "bulk",
        "Received": "(from raph@localhost)\n\tby lizardbreath.artofcode.com (8.9.3/8.9.3) id OAA17491;\n\tMon, 24 Jul 2000 14:35:53 -0700",
        "Return-Path": "<raph@acm.org>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "ART_HACKPDF 1.4 transparency",
        "To": "libart-hackers@gnome.org",
        "X-Authentication-Warning": "lizardbreath.artofcode.com: raph set sender to raph@acm.org using -f",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0beta2",
        "body": {
            "plain": "[This is a copy of an email written to L. Peter Deutsch regarding\nadding PDF 1.4 transparency to Ghostscript. It is likely to be of some\ninterest to Libart hackers, as I'm planning on supporting the full PDF\n1.4 transparency model in Libart.]\n\n   I promised I'd write you in more detail when I'd had a chance to\nabsorb the PDF 1.4 transparency spec:\nhttp://partners.adobe.com/asn/developer/acrosdk/DOCS/PDF_Transparency.pdf\n\n   I've just gone through another pass-through, and _still_ don't feel\nI fully understand it, but have enough insight that we can start\nproductively talking about the impact on the gs code base.\n\n   Let me start by expressing a few concerns. Patents top the list.\nAdobe basically gives notice that there _will_ be patents covering PDF\n1.4, and that no license for these patents is implied unless Adobe\npublishes a Patent Clarification Notice. Pierre tells me (informally!)\nthat Adobe will probably grant any generic patents on the transparency\nmodel, but will keep specific implementation techniques. This could be\nan area of major concern - I believe the difference in speed (and\npossibly quality) between a naive implementation and a clever one is\nlikely to be dramatic. Pierre also tells me that his patent was filed\naround Christmastime. Thus, we're not likely to find out the status of\nthe patent situation for another year or two.\n\n   My other concern is the inconsistency between different\nimplementations. In particular, an implementation based on\nsupersampling can produce quite different results than one performing\nall rasterization at the device resolution, and simulating\nantialiasing through alpha channel techniques. In fact, from playing\nwith AI9, it's clear that Adobe has implemented _both_ techniques. In\ngeneral, they use alpha-channel for screen display, and supersampling\nfor raster image export. It is not, in fact, at all difficult to see\nvisible differences, even when the \"Pixel Preview\" View option is\nselected.\n\n   So now I believe that the issue of \"correctly implementing the\nspec\" is made considerably more complex - if you want to match Adobe's\nbehavior, you also have to match the supersample/alpha choice.\n\n   Ok, now for the fun stuff. I'm not going to assume here that you've\nread the spec in detail - even if so, I hope you may find this summary\nhelpful for purposes of intuition. The spec is not light beach reading\n:)\n\n   The basic rendering model is a tree, with \"elementary objects\" at\nthe leaves and groups everywhere else. The interpretation of this tree\nis not simple - neither the model where a group is a function of its\nchildren, nor the model of a canvas over which things are painted,\napplies. In attribute grammar terminology, rendering requires both\nsynthesized and inherited attributes.\n\n   For the purpose of our discussion, I think the most illuminating\nmodel will be traversal of the tree while modifying a stack of\ntemporary images, with the obvious mapping between stack depth and\nlevel in the tree. Each intermediate image has pixels composed of one\nscalar per device color component, plus two alpha values, called\n\"shape\" and \"opacity\". Note that the product of opacity and shape\ncorresponds directly to classical \"alpha\". The distinction becomes\nimportant only in the case of knockout.\n\n   Exactly what happens on tree pushing and popping depends on two\nboolean flags: \"isolated\" and \"knockout\". Furthermore, all objects\n(groups and elementary objects both) have an associated blending mode\nthat controls how the top-of-stack image gets composited over the\nnext-to-top-of stack. The blending function itself is function of two\ncolors, ie, result_color = blend (background_color,\nforeground_color). It might be help your intuition to know that Normal\n(bg, fg) = fg. Compositing extends the blending function in a more or\nless expected manner to handle alpha. Thus, the compositing function\nspecialized to the Normal blend mode is exactly equivalent to\nPorter-Duff \"over\".\n\n   Note that the spec does _not_ specify the actual behavior the\nblending modes. I don't remember our conversation well, but it seems\nto me I win something for predicting that. In any case, I have\nsuccessfully reverse engineered all the separable blend functions to\n+/- 2 pixel counts, so it's not a stumbling block.\n\n   The simplest case is isolated and !knockout. In this case, pushing\nthe stack creates a new, empty image. After the children are then\ncomposited to the top of the stack, popping the stack composites the\ntop-of-stack over the second-on-stack using the blending function\nspecified in the group.\n\n   The !isolated and !knockout case involves a bit of cleverness. In\nthis case, pushing the stack dup's the top-of-stack image. Popping the\nstack involves an _uncompositing_ operation, then recompositing using\nthe normal blending mode. More specifically, if the second-on-stack is\nx and the tos is y, you solve $y = z over x$ for z, then composite z\nover x using the blending function specified in the group. In the case\nwhere the blending function and masks all reduce to Porter-Duff\n\"over\", the uncompositing and recompositing cancel each other out. In\nthe case of other blend modes, interesting and nontrivial things\nhappen.\n\n   I'm not going to define the knockout cases in detail here (they are\nhairy). However, here is an outline for the purpose of intuition:\npushing the stack copies the tos to a temporary image buffer. Each\nchild is composited over this temporary image buffer, in a \"sandbox\"\n(you can push the stack and use that as the \"sandbox\" if that helps\nvisualize it). Then, this result is composited over the tos using a\nrather intricate compositing function defined in terms of both shape\nand opacity. Effectively, instead of the images being composited in a\nstack (ie, i3 over i2 over i1), each indvidual object is separately\ncomposed over the backdrop (ie some composition of (i1 over backdrop),\n(i2 over backdrop) and (i3 over backdrop)). Popping the stack then\nworks analogously to the !knockout cases.\n\n   Efficiently implementing PDF 1.4 transparency is a very large\nkettle of worms. A naive implementation would clearly be very\nslow. The space of potential optimizations is large and diverse. Here\nis a somwhat random list:\n\n1. Having separate shape and opacity is not necessary in the common\n   case. I believe that a simple and effective criterion is whether\n   any ancestor in the group tree has the \"knockout\" option set. If\n   not, alpha can be safely computed as a single channel.\n\n2. Algebraic simplification. There are a whole buch of little things\n   here - for example, in groups with Normal blend mode and no mask,\n   you can usually just remove the enclosing push/pop. The same\n   generally applies for groups with one object. Also, when the\n   composition backdrop is known to be blank, much simpler math can be\n   used.\n\n3. Local simplification. For example, compositing a group in\n   non-isolated mode with a Normal blending mode but nonunity opacity\n   can be done in one shot rather than uncompositing and\n   recompositing.\n\n4. Region-based simplification. It is very common for objects to large\n   regions of zero alpha, unity alpha, etc. Within these regions,\n   compositing can be simplified dramatically. In areas of zero alpha,\n   you don't have to touch the pixels at all, which is a _huge_ win.\n\n5. Computations in vector space. If you have elementary objects of\n   flat color, it may make sense to analytically split them up into\n   venn-diagram subareas, then compute the transparency color only\n   once per area. The advantage of this technique is that it scales up\n   very nicely as rez goes up. The disadvantages are numerous,\n   including numerical stability issues and the possibility for a\n   combinatorial explosion of pieces. Yet, I do know that Adobe has\n   implemented this for PostScript and pre-1.4 PDF output.\n\n6. Runlength computations. Again, for regions of flat color, a\n   runlength representation makes sense. This is simpler and lower\n   level than computing in vector space.\n\n7. Adaptive resolution rendering. Neither vector-space nor runlength\n   computations will work in general for gradients. However,\n   generating gradients at 2400 (or even 720) dpi and doing the\n   blending pixel-by-pixel can be incredibly wasteful, when you can\n   get almost exactly the same results computing the interior at\n   dramatically reduced resolution.\n\n8. Judicious choice of premultiplied vs. separated alpha. Separated\n   alpha is fastest in the common case of compositing rgba images over\n   an rgb buffer (similarly for cmyk). However, working with\n   intermediate groups in Normal blend mode, premultiplied is going to\n   be faster. For many operations (such as abNormal blend modes), it's\n   probably a wash.\n\n   Lastly, I've been thinking about supersampling. Consider three\ndifferent rendering strategies: no antialiasing, alpha-compositing\nbased aa, and supersampling. In the common case, many pixels will be\nidentical across all three versions.\n\n   I hypothesize that the following criteria can predict when the\npixel values will be identical: for each object, compute a bitmap with\nvalue 0 where there is no edge present inside the pixel, 1 where there\nis an edge present. Then add all these bitmaps pointwise. For values\nof 0, the three rendered images will match. For values of 1, the alpha\nand supersampled images will match, but will in general differ from\nthe non-aa. For values of 2 or greater, none in general will match.\n\n   If this hypothesis is true, then a valid rendering strategy would\nbe to render the entire image using alpha compositing, then rework all\npixels with >= 2 counts with supersampling. Treating the 0 case\nspecially is not likely to help much, as libart already fills in\nnon-edge pixels at memset speeds.\n\n   It's interesting to note that Adobe Illustrator 9 appears to\nimplement supersampling naively. In all tests I've done, memory usage\nand cpu seem to scale quite linearly with areal resolution (ie\nquadratically with linear rez).\n\n   Lastly, while some of these optimizations fit in nicely with the\nexisting PostScript code to traverse the PDF structure, others may\nnot. I think we need to carefully select a set of optimizations that\ndo a reasonable job simplifying the common case, while ideally not\naffecting the structure of the gs code base too drastically.\n\nTake care,\n\nRaph\n[This is a copy of an email written to L. Peter Deutsch regarding\nadding PDF 1.4 transparency to Ghostscript. It is likely to be of some\ninterest to Libart hackers, as I'm planning on supporting the full PDF\n1.4 transparency model in Libart.]\n\n   I promised I'd write you in more detail when I'd had a chance to\nabsorb the PDF 1.4 transparency spec:\nhttp://partners.adobe.com/asn/developer/acrosdk/DOCS/PDF_Transparency.pdf\n\n   I've just gone through another pass-through, and _still_ don't feel\nI fully understand it, but have enough insight that we can start\nproductively talking about the impact on the gs code base.\n\n   Let me start by expressing a few concerns. Patents top the list.\nAdobe basically gives notice that there _will_ be patents covering PDF\n1.4, and that no license for these patents is implied unless Adobe\npublishes a Patent Clarification Notice. Pierre tells me (informally!)\nthat Adobe will probably grant any generic patents on the transparency\nmodel, but will keep specific implementation techniques. This could be\nan area of major concern - I believe the difference in speed (and\npossibly quality) between a naive implementation and a clever one is\nlikely to be dramatic. Pierre also tells me that his patent was filed\naround Christmastime. Thus, we're not likely to find out the status of\nthe patent situation for another year or two.\n\n   My other concern is the inconsistency between different\nimplementations. In particular, an implementation based on\nsupersampling can produce quite different results than one performing\nall rasterization at the device resolution, and simulating\nantialiasing through alpha channel techniques. In fact, from playing\nwith AI9, it's clear that Adobe has implemented _both_ techniques. In\ngeneral, they use alpha-channel for screen display, and supersampling\nfor raster image export. It is not, in fact, at all difficult to see\nvisible differences, even when the \"Pixel Preview\" View option is\nselected.\n\n   So now I believe that the issue of \"correctly implementing the\nspec\" is made considerably more complex - if you want to match Adobe's\nbehavior, you also have to match the supersample/alpha choice.\n\n   Ok, now for the fun stuff. I'm not going to assume here that you've\nread the spec in detail - even if so, I hope you may find this summary\nhelpful for purposes of intuition. The spec is not light beach reading\n:)\n\n   The basic rendering model is a tree, with \"elementary objects\" at\nthe leaves and groups everywhere else. The interpretation of this tree\nis not simple - neither the model where a group is a function of its\nchildren, nor the model of a canvas over which things are painted,\napplies. In attribute grammar terminology, rendering requires both\nsynthesized and inherited attributes.\n\n   For the purpose of our discussion, I think the most illuminating\nmodel will be traversal of the tree while modifying a stack of\ntemporary images, with the obvious mapping between stack depth and\nlevel in the tree. Each intermediate image has pixels composed of one\nscalar per device color component, plus two alpha values, called\n\"shape\" and \"opacity\". Note that the product of opacity and shape\ncorresponds directly to classical \"alpha\". The distinction becomes\nimportant only in the case of knockout.\n\n   Exactly what happens on tree pushing and popping depends on two\nboolean flags: \"isolated\" and \"knockout\". Furthermore, all objects\n(groups and elementary objects both) have an associated blending mode\nthat controls how the top-of-stack image gets composited over the\nnext-to-top-of stack. The blending function itself is function of two\ncolors, ie, result_color = blend (background_color,\nforeground_color). It might be help your intuition to know that Normal\n(bg, fg) = fg. Compositing extends the blending function in a more or\nless expected manner to handle alpha. Thus, the compositing function\nspecialized to the Normal blend mode is exactly equivalent to\nPorter-Duff \"over\".\n\n   Note that the spec does _not_ specify the actual behavior the\nblending modes. I don't remember our conversation well, but it seems\nto me I win something for predicting that. In any case, I have\nsuccessfully reverse engineered all the separable blend functions to\n+/- 2 pixel counts, so it's not a stumbling block.\n\n   The simplest case is isolated and !knockout. In this case, pushing\nthe stack creates a new, empty image. After the children are then\ncomposited to the top of the stack, popping the stack composites the\ntop-of-stack over the second-on-stack using the blending function\nspecified in the group.\n\n   The !isolated and !knockout case involves a bit of cleverness. In\nthis case, pushing the stack dup's the top-of-stack image. Popping the\nstack involves an _uncompositing_ operation, then recompositing using\nthe normal blending mode. More specifically, if the second-on-stack is\nx and the tos is y, you solve $y = z over x$ for z, then composite z\nover x using the blending function specified in the group. In the case\nwhere the blending function and masks all reduce to Porter-Duff\n\"over\", the uncompositing and recompositing cancel each other out. In\nthe case of other blend modes, interesting and nontrivial things\nhappen.\n\n   I'm not going to define the knockout cases in detail here (they are\nhairy). However, here is an outline for the purpose of intuition:\npushing the stack copies the tos to a temporary image buffer. Each\nchild is composited over this temporary image buffer, in a \"sandbox\"\n(you can push the stack and use that as the \"sandbox\" if that helps\nvisualize it). Then, this result is composited over the tos using a\nrather intricate compositing function defined in terms of both shape\nand opacity. Effectively, instead of the images being composited in a\nstack (ie, i3 over i2 over i1), each indvidual object is separately\ncomposed over the backdrop (ie some composition of (i1 over backdrop),\n(i2 over backdrop) and (i3 over backdrop)). Popping the stack then\nworks analogously to the !knockout cases.\n\n   Efficiently implementing PDF 1.4 transparency is a very large\nkettle of worms. A naive implementation would clearly be very\nslow. The space of potential optimizations is large and diverse. Here\nis a somwhat random list:\n\n1. Having separate shape and opacity is not necessary in the common\n   case. I believe that a simple and effective criterion is whether\n   any ancestor in the group tree has the \"knockout\" option set. If\n   not, alpha can be safely computed as a single channel.\n\n2. Algebraic simplification. There are a whole buch of little things\n   here - for example, in groups with Normal blend mode and no mask,\n   you can usually just remove the enclosing push/pop. The same\n   generally applies for groups with one object. Also, when the\n   composition backdrop is known to be blank, much simpler math can be\n   used.\n\n3. Local simplification. For example, compositing a group in\n   non-isolated mode with a Normal blending mode but nonunity opacity\n   can be done in one shot rather than uncompositing and\n   recompositing.\n\n4. Region-based simplification. It is very common for objects to large\n   regions of zero alpha, unity alpha, etc. Within these regions,\n   compositing can be simplified dramatically. In areas of zero alpha,\n   you don't have to touch the pixels at all, which is a _huge_ win.\n\n5. Computations in vector space. If you have elementary objects of\n   flat color, it may make sense to analytically split them up into\n   venn-diagram subareas, then compute the transparency color only\n   once per area. The advantage of this technique is that it scales up\n   very nicely as rez goes up. The disadvantages are numerous,\n   including numerical stability issues and the possibility for a\n   combinatorial explosion of pieces. Yet, I do know that Adobe has\n   implemented this for PostScript and pre-1.4 PDF output.\n\n6. Runlength computations. Again, for regions of flat color, a\n   runlength representation makes sense. This is simpler and lower\n   level than computing in vector space.\n\n7. Adaptive resolution rendering. Neither vector-space nor runlength\n   computations will work in general for gradients. However,\n   generating gradients at 2400 (or even 720) dpi and doing the\n   blending pixel-by-pixel can be incredibly wasteful, when you can\n   get almost exactly the same results computing the interior at\n   dramatically reduced resolution.\n\n8. Judicious choice of premultiplied vs. separated alpha. Separated\n   alpha is fastest in the common case of compositing rgba images over\n   an rgb buffer (similarly for cmyk). However, working with\n   intermediate groups in Normal blend mode, premultiplied is going to\n   be faster. For many operations (such as abNormal blend modes), it's\n   probably a wash.\n\n   Lastly, I've been thinking about supersampling. Consider three\ndifferent rendering strategies: no antialiasing, alpha-compositing\nbased aa, and supersampling. In the common case, many pixels will be\nidentical across all three versions.\n\n   I hypothesize that the following criteria can predict when the\npixel values will be identical: for each object, compute a bitmap with\nvalue 0 where there is no edge present inside the pixel, 1 where there\nis an edge present. Then add all these bitmaps pointwise. For values\nof 0, the three rendered images will match. For values of 1, the alpha\nand supersampled images will match, but will in general differ from\nthe non-aa. For values of 2 or greater, none in general will match.\n\n   If this hypothesis is true, then a valid rendering strategy would\nbe to render the entire image using alpha compositing, then rework all\npixels with >= 2 counts with supersampling. Treating the 0 case\nspecially is not likely to help much, as libart already fills in\nnon-edge pixels at memset speeds.\n\n   It's interesting to note that Adobe Illustrator 9 appears to\nimplement supersampling naively. In all tests I've done, memory usage\nand cpu seem to scale quite linearly with areal resolution (ie\nquadratically with linear rez).\n\n   Lastly, while some of these optimizations fit in nicely with the\nexisting PostScript code to traverse the PDF structure, others may\nnot. I think we need to carefully select a set of optimizations that\ndo a reasonable job simplifying the common case, while ideally not\naffecting the structure of the gs code base too drastically.\n\nTake care,\n\nRaph\n[This is a copy of an email written to L. Peter Deutsch regarding\nadding PDF 1.4 transparency to Ghostscript. It is likely to be of some\ninterest to Libart hackers, as I'm planning on supporting the full PDF\n1.4 transparency model in Libart.]\n\n   I promised I'd write you in more detail when I'd had a chance to\nabsorb the PDF 1.4 transparency spec:\nhttp://partners.adobe.com/asn/developer/acrosdk/DOCS/PDF_Transparency.pdf\n\n   I've just gone through another pass-through, and _still_ don't feel\nI fully understand it, but have enough insight that we can start\nproductively talking about the impact on the gs code base.\n\n   Let me start by expressing a few concerns. Patents top the list.\nAdobe basically gives notice that there _will_ be patents covering PDF\n1.4, and that no license for these patents is implied unless Adobe\npublishes a Patent Clarification Notice. Pierre tells me (informally!)\nthat Adobe will probably grant any generic patents on the transparency\nmodel, but will keep specific implementation techniques. This could be\nan area of major concern - I believe the difference in speed (and\npossibly quality) between a naive implementation and a clever one is\nlikely to be dramatic. Pierre also tells me that his patent was filed\naround Christmastime. Thus, we're not likely to find out the status of\nthe patent situation for another year or two.\n\n   My other concern is the inconsistency between different\nimplementations. In particular, an implementation based on\nsupersampling can produce quite different results than one performing\nall rasterization at the device resolution, and simulating\nantialiasing through alpha channel techniques. In fact, from playing\nwith AI9, it's clear that Adobe has implemented _both_ techniques. In\ngeneral, they use alpha-channel for screen display, and supersampling\nfor raster image export. It is not, in fact, at all difficult to see\nvisible differences, even when the \"Pixel Preview\" View option is\nselected.\n\n   So now I believe that the issue of \"correctly implementing the\nspec\" is made considerably more complex - if you want to match Adobe's\nbehavior, you also have to match the supersample/alpha choice.\n\n   Ok, now for the fun stuff. I'm not going to assume here that you've\nread the spec in detail - even if so, I hope you may find this summary\nhelpful for purposes of intuition. The spec is not light beach reading\n:)\n\n   The basic rendering model is a tree, with \"elementary objects\" at\nthe leaves and groups everywhere else. The interpretation of this tree\nis not simple - neither the model where a group is a function of its\nchildren, nor the model of a canvas over which things are painted,\napplies. In attribute grammar terminology, rendering requires both\nsynthesized and inherited attributes.\n\n   For the purpose of our discussion, I think the most illuminating\nmodel will be traversal of the tree while modifying a stack of\ntemporary images, with the obvious mapping between stack depth and\nlevel in the tree. Each intermediate image has pixels composed of one\nscalar per device color component, plus two alpha values, called\n\"shape\" and \"opacity\". Note that the product of opacity and shape\ncorresponds directly to classical \"alpha\". The distinction becomes\nimportant only in the case of knockout.\n\n   Exactly what happens on tree pushing and popping depends on two\nboolean flags: \"isolated\" and \"knockout\". Furthermore, all objects\n(groups and elementary objects both) have an associated blending mode\nthat controls how the top-of-stack image gets composited over the\nnext-to-top-of stack. The blending function itself is function of two\ncolors, ie, result_color = blend (background_color,\nforeground_color). It might be help your intuition to know that Normal\n(bg, fg) = fg. Compositing extends the blending function in a more or\nless expected manner to handle alpha. Thus, the compositing function\nspecialized to the Normal blend mode is exactly equivalent to\nPorter-Duff \"over\".\n\n   Note that the spec does _not_ specify the actual behavior the\nblending modes. I don't remember our conversation well, but it seems\nto me I win something for predicting that. In any case, I have\nsuccessfully reverse engineered all the separable blend functions to\n+/- 2 pixel counts, so it's not a stumbling block.\n\n   The simplest case is isolated and !knockout. In this case, pushing\nthe stack creates a new, empty image. After the children are then\ncomposited to the top of the stack, popping the stack composites the\ntop-of-stack over the second-on-stack using the blending function\nspecified in the group.\n\n   The !isolated and !knockout case involves a bit of cleverness. In\nthis case, pushing the stack dup's the top-of-stack image. Popping the\nstack involves an _uncompositing_ operation, then recompositing using\nthe normal blending mode. More specifically, if the second-on-stack is\nx and the tos is y, you solve $y = z over x$ for z, then composite z\nover x using the blending function specified in the group. In the case\nwhere the blending function and masks all reduce to Porter-Duff\n\"over\", the uncompositing and recompositing cancel each other out. In\nthe case of other blend modes, interesting and nontrivial things\nhappen.\n\n   I'm not going to define the knockout cases in detail here (they are\nhairy). However, here is an outline for the purpose of intuition:\npushing the stack copies the tos to a temporary image buffer. Each\nchild is composited over this temporary image buffer, in a \"sandbox\"\n(you can push the stack and use that as the \"sandbox\" if that helps\nvisualize it). Then, this result is composited over the tos using a\nrather intricate compositing function defined in terms of both shape\nand opacity. Effectively, instead of the images being composited in a\nstack (ie, i3 over i2 over i1), each indvidual object is separately\ncomposed over the backdrop (ie some composition of (i1 over backdrop),\n(i2 over backdrop) and (i3 over backdrop)). Popping the stack then\nworks analogously to the !knockout cases.\n\n   Efficiently implementing PDF 1.4 transparency is a very large\nkettle of worms. A naive implementation would clearly be very\nslow. The space of potential optimizations is large and diverse. Here\nis a somwhat random list:\n\n1. Having separate shape and opacity is not necessary in the common\n   case. I believe that a simple and effective criterion is whether\n   any ancestor in the group tree has the \"knockout\" option set. If\n   not, alpha can be safely computed as a single channel.\n\n2. Algebraic simplification. There are a whole buch of little things\n   here - for example, in groups with Normal blend mode and no mask,\n   you can usually just remove the enclosing push/pop. The same\n   generally applies for groups with one object. Also, when the\n   composition backdrop is known to be blank, much simpler math can be\n   used.\n\n3. Local simplification. For example, compositing a group in\n   non-isolated mode with a Normal blending mode but nonunity opacity\n   can be done in one shot rather than uncompositing and\n   recompositing.\n\n4. Region-based simplification. It is very common for objects to large\n   regions of zero alpha, unity alpha, etc. Within these regions,\n   compositing can be simplified dramatically. In areas of zero alpha,\n   you don't have to touch the pixels at all, which is a _huge_ win.\n\n5. Computations in vector space. If you have elementary objects of\n   flat color, it may make sense to analytically split them up into\n   venn-diagram subareas, then compute the transparency color only\n   once per area. The advantage of this technique is that it scales up\n   very nicely as rez goes up. The disadvantages are numerous,\n   including numerical stability issues and the possibility for a\n   combinatorial explosion of pieces. Yet, I do know that Adobe has\n   implemented this for PostScript and pre-1.4 PDF output.\n\n6. Runlength computations. Again, for regions of flat color, a\n   runlength representation makes sense. This is simpler and lower\n   level than computing in vector space.\n\n7. Adaptive resolution rendering. Neither vector-space nor runlength\n   computations will work in general for gradients. However,\n   generating gradients at 2400 (or even 720) dpi and doing the\n   blending pixel-by-pixel can be incredibly wasteful, when you can\n   get almost exactly the same results computing the interior at\n   dramatically reduced resolution.\n\n8. Judicious choice of premultiplied vs. separated alpha. Separated\n   alpha is fastest in the common case of compositing rgba images over\n   an rgb buffer (similarly for cmyk). However, working with\n   intermediate groups in Normal blend mode, premultiplied is going to\n   be faster. For many operations (such as abNormal blend modes), it's\n   probably a wash.\n\n   Lastly, I've been thinking about supersampling. Consider three\ndifferent rendering strategies: no antialiasing, alpha-compositing\nbased aa, and supersampling. In the common case, many pixels will be\nidentical across all three versions.\n\n   I hypothesize that the following criteria can predict when the\npixel values will be identical: for each object, compute a bitmap with\nvalue 0 where there is no edge present inside the pixel, 1 where there\nis an edge present. Then add all these bitmaps pointwise. For values\nof 0, the three rendered images will match. For values of 1, the alpha\nand supersampled images will match, but will in general differ from\nthe non-aa. For values of 2 or greater, none in general will match.\n\n   If this hypothesis is true, then a valid rendering strategy would\nbe to render the entire image using alpha compositing, then rework all\npixels with >= 2 counts with supersampling. Treating the 0 case\nspecially is not likely to help much, as libart already fills in\nnon-edge pixels at memset speeds.\n\n   It's interesting to note that Adobe Illustrator 9 appears to\nimplement supersampling naively. In all tests I've done, memory usage\nand cpu seem to scale quite linearly with areal resolution (ie\nquadratically with linear rez).\n\n   Lastly, while some of these optimizations fit in nicely with the\nexisting PostScript code to traverse the PDF structure, others may\nnot. I think we need to carefully select a set of optimizations that\ndo a reasonable job simplifying the common case, while ideally not\naffecting the structure of the gs code base too drastically.\n\nTake care,\n\nRaph\n[This is a copy of an email written to L. Peter Deutsch regarding\nadding PDF 1.4 transparency to Ghostscript. It is likely to be of some\ninterest to Libart hackers, as I'm planning on supporting the full PDF\n1.4 transparency model in Libart.]\n\n   I promised I'd write you in more detail when I'd had a chance to\nabsorb the PDF 1.4 transparency spec:\nhttp://partners.adobe.com/asn/developer/acrosdk/DOCS/PDF_Transparency.pdf\n\n   I've just gone through another pass-through, and _still_ don't feel\nI fully understand it, but have enough insight that we can start\nproductively talking about the impact on the gs code base.\n\n   Let me start by expressing a few concerns. Patents top the list.\nAdobe basically gives notice that there _will_ be patents covering PDF\n1.4, and that no license for these patents is implied unless Adobe\npublishes a Patent Clarification Notice. Pierre tells me (informally!)\nthat Adobe will probably grant any generic patents on the transparency\nmodel, but will keep specific implementation techniques. This could be\nan area of major concern - I believe the difference in speed (and\npossibly quality) between a naive implementation and a clever one is\nlikely to be dramatic. Pierre also tells me that his patent was filed\naround Christmastime. Thus, we're not likely to find out the status of\nthe patent situation for another year or two.\n\n   My other concern is the inconsistency between different\nimplementations. In particular, an implementation based on\nsupersampling can produce quite different results than one performing\nall rasterization at the device resolution, and simulating\nantialiasing through alpha channel techniques. In fact, from playing\nwith AI9, it's clear that Adobe has implemented _both_ techniques. In\ngeneral, they use alpha-channel for screen display, and supersampling\nfor raster image export. It is not, in fact, at all difficult to see\nvisible differences, even when the \"Pixel Preview\" View option is\nselected.\n\n   So now I believe that the issue of \"correctly implementing the\nspec\" is made considerably more complex - if you want to match Adobe's\nbehavior, you also have to match the supersample/alpha choice.\n\n   Ok, now for the fun stuff. I'm not going to assume here that you've\nread the spec in detail - even if so, I hope you may find this summary\nhelpful for purposes of intuition. The spec is not light beach reading\n:)\n\n   The basic rendering model is a tree, with \"elementary objects\" at\nthe leaves and groups everywhere else. The interpretation of this tree\nis not simple - neither the model where a group is a function of its\nchildren, nor the model of a canvas over which things are painted,\napplies. In attribute grammar terminology, rendering requires both\nsynthesized and inherited attributes.\n\n   For the purpose of our discussion, I think the most illuminating\nmodel will be traversal of the tree while modifying a stack of\ntemporary images, with the obvious mapping between stack depth and\nlevel in the tree. Each intermediate image has pixels composed of one\nscalar per device color component, plus two alpha values, called\n\"shape\" and \"opacity\". Note that the product of opacity and shape\ncorresponds directly to classical \"alpha\". The distinction becomes\nimportant only in the case of knockout.\n\n   Exactly what happens on tree pushing and popping depends on two\nboolean flags: \"isolated\" and \"knockout\". Furthermore, all objects\n(groups and elementary objects both) have an associated blending mode\nthat controls how the top-of-stack image gets composited over the\nnext-to-top-of stack. The blending function itself is function of two\ncolors, ie, result_color = blend (background_color,\nforeground_color). It might be help your intuition to know that Normal\n(bg, fg) = fg. Compositing extends the blending function in a more or\nless expected manner to handle alpha. Thus, the compositing function\nspecialized to the Normal blend mode is exactly equivalent to\nPorter-Duff \"over\".\n\n   Note that the spec does _not_ specify the actual behavior the\nblending modes. I don't remember our conversation well, but it seems\nto me I win something for predicting that. In any case, I have\nsuccessfully reverse engineered all the separable blend functions to\n+/- 2 pixel counts, so it's not a stumbling block.\n\n   The simplest case is isolated and !knockout. In this case, pushing\nthe stack creates a new, empty image. After the children are then\ncomposited to the top of the stack, popping the stack composites the\ntop-of-stack over the second-on-stack using the blending function\nspecified in the group.\n\n   The !isolated and !knockout case involves a bit of cleverness. In\nthis case, pushing the stack dup's the top-of-stack image. Popping the\nstack involves an _uncompositing_ operation, then recompositing using\nthe normal blending mode. More specifically, if the second-on-stack is\nx and the tos is y, you solve $y = z over x$ for z, then composite z\nover x using the blending function specified in the group. In the case\nwhere the blending function and masks all reduce to Porter-Duff\n\"over\", the uncompositing and recompositing cancel each other out. In\nthe case of other blend modes, interesting and nontrivial things\nhappen.\n\n   I'm not going to define the knockout cases in detail here (they are\nhairy). However, here is an outline for the purpose of intuition:\npushing the stack copies the tos to a temporary image buffer. Each\nchild is composited over this temporary image buffer, in a \"sandbox\"\n(you can push the stack and use that as the \"sandbox\" if that helps\nvisualize it). Then, this result is composited over the tos using a\nrather intricate compositing function defined in terms of both shape\nand opacity. Effectively, instead of the images being composited in a\nstack (ie, i3 over i2 over i1), each indvidual object is separately\ncomposed over the backdrop (ie some composition of (i1 over backdrop),\n(i2 over backdrop) and (i3 over backdrop)). Popping the stack then\nworks analogously to the !knockout cases.\n\n   Efficiently implementing PDF 1.4 transparency is a very large\nkettle of worms. A naive implementation would clearly be very\nslow. The space of potential optimizations is large and diverse. Here\nis a somwhat random list:\n\n1. Having separate shape and opacity is not necessary in the common\n   case. I believe that a simple and effective criterion is whether\n   any ancestor in the group tree has the \"knockout\" option set. If\n   not, alpha can be safely computed as a single channel.\n\n2. Algebraic simplification. There are a whole buch of little things\n   here - for example, in groups with Normal blend mode and no mask,\n   you can usually just remove the enclosing push/pop. The same\n   generally applies for groups with one object. Also, when the\n   composition backdrop is known to be blank, much simpler math can be\n   used.\n\n3. Local simplification. For example, compositing a group in\n   non-isolated mode with a Normal blending mode but nonunity opacity\n   can be done in one shot rather than uncompositing and\n   recompositing.\n\n4. Region-based simplification. It is very common for objects to large\n   regions of zero alpha, unity alpha, etc. Within these regions,\n   compositing can be simplified dramatically. In areas of zero alpha,\n   you don't have to touch the pixels at all, which is a _huge_ win.\n\n5. Computations in vector space. If you have elementary objects of\n   flat color, it may make sense to analytically split them up into\n   venn-diagram subareas, then compute the transparency color only\n   once per area. The advantage of this technique is that it scales up\n   very nicely as rez goes up. The disadvantages are numerous,\n   including numerical stability issues and the possibility for a\n   combinatorial explosion of pieces. Yet, I do know that Adobe has\n   implemented this for PostScript and pre-1.4 PDF output.\n\n6. Runlength computations. Again, for regions of flat color, a\n   runlength representation makes sense. This is simpler and lower\n   level than computing in vector space.\n\n7. Adaptive resolution rendering. Neither vector-space nor runlength\n   computations will work in general for gradients. However,\n   generating gradients at 2400 (or even 720) dpi and doing the\n   blending pixel-by-pixel can be incredibly wasteful, when you can\n   get almost exactly the same results computing the interior at\n   dramatically reduced resolution.\n\n8. Judicious choice of premultiplied vs. separated alpha. Separated\n   alpha is fastest in the common case of compositing rgba images over\n   an rgb buffer (similarly for cmyk). However, working with\n   intermediate groups in Normal blend mode, premultiplied is going to\n   be faster. For many operations (such as abNormal blend modes), it's\n   probably a wash.\n\n   Lastly, I've been thinking about supersampling. Consider three\ndifferent rendering strategies: no antialiasing, alpha-compositing\nbased aa, and supersampling. In the common case, many pixels will be\nidentical across all three versions.\n\n   I hypothesize that the following criteria can predict when the\npixel values will be identical: for each object, compute a bitmap with\nvalue 0 where there is no edge present inside the pixel, 1 where there\nis an edge present. Then add all these bitmaps pointwise. For values\nof 0, the three rendered images will match. For values of 1, the alpha\nand supersampled images will match, but will in general differ from\nthe non-aa. For values of 2 or greater, none in general will match.\n\n   If this hypothesis is true, then a valid rendering strategy would\nbe to render the entire image using alpha compositing, then rework all\npixels with >= 2 counts with supersampling. Treating the 0 case\nspecially is not likely to help much, as libart already fills in\nnon-edge pixels at memset speeds.\n\n   It's interesting to note that Adobe Illustrator 9 appears to\nimplement supersampling naively. In all tests I've done, memory usage\nand cpu seem to scale quite linearly with areal resolution (ie\nquadratically with linear rez).\n\n   Lastly, while some of these optimizations fit in nicely with the\nexisting PostScript code to traverse the PDF structure, others may\nnot. I think we need to carefully select a set of optimizations that\ndo a reasonable job simplifying the common case, while ideally not\naffecting the structure of the gs code base too drastically.\n\nTake care,\n\nRaph\n"
        },
        "unixfrom": "raph@acm.org  Mon Jul 24 17:34:04 2000"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.143259,
    "updated_on": 964474553.0,
    "uuid": "81958c2e3abc8515dd2cfa905e7a115cb36c19f1"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "ART_HACKPDF 1.4 transparency",
    "data": {
        "Content-Type": "MULTIPART/MIXED; BOUNDARY=\"-1345348566-1290319401-1005931453=:14570\"",
        "Date": "Fri, 16 Nov 2001 12:24:13 -0500 (EST)",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Alex Larsson <alexl@redhat.com>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-Version": "1.0",
        "Message-ID": "<Pine.LNX.4.33.0111161156190.14570-200000@devserv.devel.redhat.com>",
        "Precedence": "bulk",
        "Received": "from localhost (alexl@localhost)\n\tby devserv.devel.redhat.com (8.11.0/8.11.0) with ESMTP id fAGHODm09228;\n\tFri, 16 Nov 2001 12:24:13 -0500",
        "Return-Path": "<alexl@redhat.com>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] libart patch",
        "To": "<libart-hackers@gnome.org>, <raph@acm.org>,\n\t<gnome-libs-devel@gnome.org>",
        "X-Authentication-Warning": "devserv.devel.redhat.com: alexl owned process doing -bs",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0.6",
        "X-X-Sender": "<alexl@devserv.devel.redhat.com>",
        "body": {
            "plain": "art_drect_svp() and art_drect_svp_union() are broken for svps that only \ncontain segments that are \"empty\" accoding to art_drect_empty(). This is \ntrue for i.e. rectangles. Since the bboxes of the segments either have \nzero width or zero height the resultant union bbox is empty.\n\nI will commit the attached patch to cvs that sort of fixes this for some \ncases, but in general the way libart handles empty rects is pretty \nbroken. If your're using libart, please review your usage of \nart_drect_svp(),  art_drect_svp_union(), art_drect_empty() and\nart_drect_union().\n\n/ Alex\n\nIndex: art_rect_svp.c\r\n===================================================================\r\nRCS file: /cvs/gnome/libart_lgpl/art_rect_svp.c,v\r\nretrieving revision 1.3\r\ndiff -u -p -r1.3 art_rect_svp.c\r\n--- art_rect_svp.c\t1999/09/01 07:04:21\t1.3\r\n+++ art_rect_svp.c\t2001/11/16 17:03:49\r\n@@ -22,6 +22,14 @@\r\n #include \"art_rect.h\"\r\n #include \"art_rect_svp.h\"\r\n \r\n+#ifndef MAX\r\n+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))\r\n+#endif /* MAX */\r\n+\r\n+#ifndef MIN\r\n+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))\r\n+#endif /* MIN */\r\n+\r\n /**\r\n  * art_drect_svp: Find the bounding box of a sorted vector path.\r\n  * @bbox: Where to store the bounding box.\r\n@@ -34,14 +42,23 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n {\r\n   int i;\r\n \r\n-  bbox->x0 = 0;\r\n-  bbox->y0 = 0;\r\n-  bbox->x1 = 0;\r\n-  bbox->y1 = 0;\r\n+  if (svp->n_segs == 0)\r\n+    {\r\n+      bbox->x0 = 0;\r\n+      bbox->y0 = 0;\r\n+      bbox->x1 = 0;\r\n+      bbox->y1 = 0;\r\n+      return;\r\n+    }\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n+  art_drect_copy (bbox, &svp->segs[0].bbox);\r\n+  \r\n+  for (i = 1; i < svp->n_segs; i++)\r\n     {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n+      bbox->x0 = MIN (bbox->x0, svp->segs[i].bbox.x0);\r\n+      bbox->y0 = MIN (bbox->y0, svp->segs[i].bbox.y0);\r\n+      bbox->x1 = MAX (bbox->x1, svp->segs[i].bbox.x1);\r\n+      bbox->y1 = MAX (bbox->y1, svp->segs[i].bbox.y1);\r\n     }\r\n }\r\n \r\n@@ -56,10 +73,8 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n void\r\n art_drect_svp_union (ArtDRect *bbox, const ArtSVP *svp)\r\n {\r\n-  int i;\r\n+  ArtDRect svp_bbox;\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n-    {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n-    }\r\n+  art_drect_svp (&svp_bbox, svp);\r\n+  art_drect_union (bbox, bbox, &svp_bbox);\r\n }\r\n"
        },
        "unixfrom": "alexl@redhat.com  Fri Nov 16 12:24:15 2001"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.156706,
    "updated_on": 1005931453.0,
    "uuid": "cb53bc103428bbf391a40db1e40b6cb3b6de7fd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] libart patch",
    "data": {
        "Content-Type": "MULTIPART/MIXED; BOUNDARY=\"-1345348566-1290319401-1005931453=:14570\"",
        "Date": "Fri, 16 Nov 2001 12:24:13 -0500 (EST)",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Alex Larsson <alexl@redhat.com>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-Version": "1.0",
        "Message-ID": "<Pine.LNX.4.33.0111161156190.14570-200000@devserv.devel.redhat.com>",
        "Precedence": "bulk",
        "Received": "from localhost (alexl@localhost)\n\tby devserv.devel.redhat.com (8.11.0/8.11.0) with ESMTP id fAGHODm09228;\n\tFri, 16 Nov 2001 12:24:13 -0500",
        "Return-Path": "<alexl@redhat.com>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] libart patch",
        "To": "<libart-hackers@gnome.org>, <raph@acm.org>,\n\t<gnome-libs-devel@gnome.org>",
        "X-Authentication-Warning": "devserv.devel.redhat.com: alexl owned process doing -bs",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0.6",
        "X-X-Sender": "<alexl@devserv.devel.redhat.com>",
        "body": {
            "plain": "art_drect_svp() and art_drect_svp_union() are broken for svps that only \ncontain segments that are \"empty\" accoding to art_drect_empty(). This is \ntrue for i.e. rectangles. Since the bboxes of the segments either have \nzero width or zero height the resultant union bbox is empty.\n\nI will commit the attached patch to cvs that sort of fixes this for some \ncases, but in general the way libart handles empty rects is pretty \nbroken. If your're using libart, please review your usage of \nart_drect_svp(),  art_drect_svp_union(), art_drect_empty() and\nart_drect_union().\n\n/ Alex\n\nIndex: art_rect_svp.c\r\n===================================================================\r\nRCS file: /cvs/gnome/libart_lgpl/art_rect_svp.c,v\r\nretrieving revision 1.3\r\ndiff -u -p -r1.3 art_rect_svp.c\r\n--- art_rect_svp.c\t1999/09/01 07:04:21\t1.3\r\n+++ art_rect_svp.c\t2001/11/16 17:03:49\r\n@@ -22,6 +22,14 @@\r\n #include \"art_rect.h\"\r\n #include \"art_rect_svp.h\"\r\n \r\n+#ifndef MAX\r\n+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))\r\n+#endif /* MAX */\r\n+\r\n+#ifndef MIN\r\n+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))\r\n+#endif /* MIN */\r\n+\r\n /**\r\n  * art_drect_svp: Find the bounding box of a sorted vector path.\r\n  * @bbox: Where to store the bounding box.\r\n@@ -34,14 +42,23 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n {\r\n   int i;\r\n \r\n-  bbox->x0 = 0;\r\n-  bbox->y0 = 0;\r\n-  bbox->x1 = 0;\r\n-  bbox->y1 = 0;\r\n+  if (svp->n_segs == 0)\r\n+    {\r\n+      bbox->x0 = 0;\r\n+      bbox->y0 = 0;\r\n+      bbox->x1 = 0;\r\n+      bbox->y1 = 0;\r\n+      return;\r\n+    }\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n+  art_drect_copy (bbox, &svp->segs[0].bbox);\r\n+  \r\n+  for (i = 1; i < svp->n_segs; i++)\r\n     {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n+      bbox->x0 = MIN (bbox->x0, svp->segs[i].bbox.x0);\r\n+      bbox->y0 = MIN (bbox->y0, svp->segs[i].bbox.y0);\r\n+      bbox->x1 = MAX (bbox->x1, svp->segs[i].bbox.x1);\r\n+      bbox->y1 = MAX (bbox->y1, svp->segs[i].bbox.y1);\r\n     }\r\n }\r\n \r\n@@ -56,10 +73,8 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n void\r\n art_drect_svp_union (ArtDRect *bbox, const ArtSVP *svp)\r\n {\r\n-  int i;\r\n+  ArtDRect svp_bbox;\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n-    {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n-    }\r\n+  art_drect_svp (&svp_bbox, svp);\r\n+  art_drect_union (bbox, bbox, &svp_bbox);\r\n }\r\n"
        },
        "unixfrom": "alexl@redhat.com  Fri Nov 16 12:24:15 2001"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.162231,
    "updated_on": 1005931453.0,
    "uuid": "cb53bc103428bbf391a40db1e40b6cb3b6de7fd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] libart patch",
    "data": {
        "Content-Type": "MULTIPART/MIXED; BOUNDARY=\"-1345348566-1290319401-1005931453=:14570\"",
        "Date": "Fri, 16 Nov 2001 12:24:13 -0500 (EST)",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Alex Larsson <alexl@redhat.com>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-Version": "1.0",
        "Message-ID": "<Pine.LNX.4.33.0111161156190.14570-200000@devserv.devel.redhat.com>",
        "Precedence": "bulk",
        "Received": "from localhost (alexl@localhost)\n\tby devserv.devel.redhat.com (8.11.0/8.11.0) with ESMTP id fAGHODm09228;\n\tFri, 16 Nov 2001 12:24:13 -0500",
        "Return-Path": "<alexl@redhat.com>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] libart patch",
        "To": "<libart-hackers@gnome.org>, <raph@acm.org>,\n\t<gnome-libs-devel@gnome.org>",
        "X-Authentication-Warning": "devserv.devel.redhat.com: alexl owned process doing -bs",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0.6",
        "X-X-Sender": "<alexl@devserv.devel.redhat.com>",
        "body": {
            "plain": "art_drect_svp() and art_drect_svp_union() are broken for svps that only \ncontain segments that are \"empty\" accoding to art_drect_empty(). This is \ntrue for i.e. rectangles. Since the bboxes of the segments either have \nzero width or zero height the resultant union bbox is empty.\n\nI will commit the attached patch to cvs that sort of fixes this for some \ncases, but in general the way libart handles empty rects is pretty \nbroken. If your're using libart, please review your usage of \nart_drect_svp(),  art_drect_svp_union(), art_drect_empty() and\nart_drect_union().\n\n/ Alex\n\nIndex: art_rect_svp.c\r\n===================================================================\r\nRCS file: /cvs/gnome/libart_lgpl/art_rect_svp.c,v\r\nretrieving revision 1.3\r\ndiff -u -p -r1.3 art_rect_svp.c\r\n--- art_rect_svp.c\t1999/09/01 07:04:21\t1.3\r\n+++ art_rect_svp.c\t2001/11/16 17:03:49\r\n@@ -22,6 +22,14 @@\r\n #include \"art_rect.h\"\r\n #include \"art_rect_svp.h\"\r\n \r\n+#ifndef MAX\r\n+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))\r\n+#endif /* MAX */\r\n+\r\n+#ifndef MIN\r\n+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))\r\n+#endif /* MIN */\r\n+\r\n /**\r\n  * art_drect_svp: Find the bounding box of a sorted vector path.\r\n  * @bbox: Where to store the bounding box.\r\n@@ -34,14 +42,23 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n {\r\n   int i;\r\n \r\n-  bbox->x0 = 0;\r\n-  bbox->y0 = 0;\r\n-  bbox->x1 = 0;\r\n-  bbox->y1 = 0;\r\n+  if (svp->n_segs == 0)\r\n+    {\r\n+      bbox->x0 = 0;\r\n+      bbox->y0 = 0;\r\n+      bbox->x1 = 0;\r\n+      bbox->y1 = 0;\r\n+      return;\r\n+    }\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n+  art_drect_copy (bbox, &svp->segs[0].bbox);\r\n+  \r\n+  for (i = 1; i < svp->n_segs; i++)\r\n     {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n+      bbox->x0 = MIN (bbox->x0, svp->segs[i].bbox.x0);\r\n+      bbox->y0 = MIN (bbox->y0, svp->segs[i].bbox.y0);\r\n+      bbox->x1 = MAX (bbox->x1, svp->segs[i].bbox.x1);\r\n+      bbox->y1 = MAX (bbox->y1, svp->segs[i].bbox.y1);\r\n     }\r\n }\r\n \r\n@@ -56,10 +73,8 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n void\r\n art_drect_svp_union (ArtDRect *bbox, const ArtSVP *svp)\r\n {\r\n-  int i;\r\n+  ArtDRect svp_bbox;\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n-    {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n-    }\r\n+  art_drect_svp (&svp_bbox, svp);\r\n+  art_drect_union (bbox, bbox, &svp_bbox);\r\n }\r\n"
        },
        "unixfrom": "alexl@redhat.com  Fri Nov 16 12:24:15 2001"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.166884,
    "updated_on": 1005931453.0,
    "uuid": "cb53bc103428bbf391a40db1e40b6cb3b6de7fd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] libart patch",
    "data": {
        "Content-Type": "MULTIPART/MIXED; BOUNDARY=\"-1345348566-1290319401-1005931453=:14570\"",
        "Date": "Fri, 16 Nov 2001 12:24:13 -0500 (EST)",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Alex Larsson <alexl@redhat.com>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-Version": "1.0",
        "Message-ID": "<Pine.LNX.4.33.0111161156190.14570-200000@devserv.devel.redhat.com>",
        "Precedence": "bulk",
        "Received": "from localhost (alexl@localhost)\n\tby devserv.devel.redhat.com (8.11.0/8.11.0) with ESMTP id fAGHODm09228;\n\tFri, 16 Nov 2001 12:24:13 -0500",
        "Return-Path": "<alexl@redhat.com>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] libart patch",
        "To": "<libart-hackers@gnome.org>, <raph@acm.org>,\n\t<gnome-libs-devel@gnome.org>",
        "X-Authentication-Warning": "devserv.devel.redhat.com: alexl owned process doing -bs",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0.6",
        "X-X-Sender": "<alexl@devserv.devel.redhat.com>",
        "body": {
            "plain": "art_drect_svp() and art_drect_svp_union() are broken for svps that only \ncontain segments that are \"empty\" accoding to art_drect_empty(). This is \ntrue for i.e. rectangles. Since the bboxes of the segments either have \nzero width or zero height the resultant union bbox is empty.\n\nI will commit the attached patch to cvs that sort of fixes this for some \ncases, but in general the way libart handles empty rects is pretty \nbroken. If your're using libart, please review your usage of \nart_drect_svp(),  art_drect_svp_union(), art_drect_empty() and\nart_drect_union().\n\n/ Alex\n\nIndex: art_rect_svp.c\r\n===================================================================\r\nRCS file: /cvs/gnome/libart_lgpl/art_rect_svp.c,v\r\nretrieving revision 1.3\r\ndiff -u -p -r1.3 art_rect_svp.c\r\n--- art_rect_svp.c\t1999/09/01 07:04:21\t1.3\r\n+++ art_rect_svp.c\t2001/11/16 17:03:49\r\n@@ -22,6 +22,14 @@\r\n #include \"art_rect.h\"\r\n #include \"art_rect_svp.h\"\r\n \r\n+#ifndef MAX\r\n+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))\r\n+#endif /* MAX */\r\n+\r\n+#ifndef MIN\r\n+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))\r\n+#endif /* MIN */\r\n+\r\n /**\r\n  * art_drect_svp: Find the bounding box of a sorted vector path.\r\n  * @bbox: Where to store the bounding box.\r\n@@ -34,14 +42,23 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n {\r\n   int i;\r\n \r\n-  bbox->x0 = 0;\r\n-  bbox->y0 = 0;\r\n-  bbox->x1 = 0;\r\n-  bbox->y1 = 0;\r\n+  if (svp->n_segs == 0)\r\n+    {\r\n+      bbox->x0 = 0;\r\n+      bbox->y0 = 0;\r\n+      bbox->x1 = 0;\r\n+      bbox->y1 = 0;\r\n+      return;\r\n+    }\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n+  art_drect_copy (bbox, &svp->segs[0].bbox);\r\n+  \r\n+  for (i = 1; i < svp->n_segs; i++)\r\n     {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n+      bbox->x0 = MIN (bbox->x0, svp->segs[i].bbox.x0);\r\n+      bbox->y0 = MIN (bbox->y0, svp->segs[i].bbox.y0);\r\n+      bbox->x1 = MAX (bbox->x1, svp->segs[i].bbox.x1);\r\n+      bbox->y1 = MAX (bbox->y1, svp->segs[i].bbox.y1);\r\n     }\r\n }\r\n \r\n@@ -56,10 +73,8 @@ art_drect_svp (ArtDRect *bbox, const Art\r\n void\r\n art_drect_svp_union (ArtDRect *bbox, const ArtSVP *svp)\r\n {\r\n-  int i;\r\n+  ArtDRect svp_bbox;\r\n \r\n-  for (i = 0; i < svp->n_segs; i++)\r\n-    {\r\n-      art_drect_union (bbox, bbox, &svp->segs[i].bbox);\r\n-    }\r\n+  art_drect_svp (&svp_bbox, svp);\r\n+  art_drect_union (bbox, bbox, &svp_bbox);\r\n }\r\n"
        },
        "unixfrom": "alexl@redhat.com  Fri Nov 16 12:24:15 2001"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.172733,
    "updated_on": 1005931453.0,
    "uuid": "cb53bc103428bbf391a40db1e40b6cb3b6de7fd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] ArtBpath",
    "data": {
        "Content-type": "multipart/alternative;\n boundary=\"Boundary_(ID_3cB7I41QIQkAMte1Uc2+lw)\"",
        "Date": "Tue, 05 Mar 2002 16:47:31 +0800",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "kevinmay@public.xm.fj.cn",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-version": "1.0",
        "Message-ID": "<005801c1c422$64134080$918842da@asshole>",
        "Precedence": "bulk",
        "Received": "from asshole ([218.66.136.145])\n by mmp2.fz.fj.cn (iPlanet Messaging Server 5.1 (built Sep  5 2001))\n with ESMTPA id <0GSH0061RRATXH@mmp2.fz.fj.cn> for libart-hackers@gnome.org;\n Tue, 05 Mar 2002 16:23:19 +0800 (CST)",
        "Return-Path": "<kevinmay@public.xm.fj.cn>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] ArtBpath",
        "To": "libart-hackers@gnome.org",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-MIMEOLE": "Produced By Microsoft MimeOLE V6.00.2462.0000",
        "X-MSMail-priority": "Normal",
        "X-Mailer": "Microsoft Outlook Express 6.00.2462.0000",
        "X-Mailman-Version": "2.0.8",
        "X-Priority": "3",
        "body": {
            "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<HTML><HEAD>\n<META http-equiv=Content-Type content=\"text/html; charset=gb2312\">\n<META content=\"MSHTML 6.00.2462.0\" name=GENERATOR>\n<STYLE></STYLE>\n</HEAD>\n<BODY bgColor=#ffffff>\n<DIV><FONT size=2>\n<DIV><FONT size=2>How to create and draw a bezier curve using ArtBpath or \nGnomeCanvasBpath on a GnomeCanvas widget?</FONT></DIV>\n<DIV><FONT size=2></FONT>&nbsp;</DIV>\n<DIV><FONT size=2>please give sample code if possible, \nthanks!</FONT></DIV></FONT></DIV></BODY></HTML>\n",
            "plain": "How to create and draw a bezier curve using ArtBpath or GnomeCanvasBpath on a GnomeCanvas widget?\n\nplease give sample code if possible, thanks!\n"
        },
        "unixfrom": "kevinmay@public.xm.fj.cn  Tue Mar  5 03:23:58 2002"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.191685,
    "updated_on": 1015318051.0,
    "uuid": "80686730d688a5a35e6c9ae170f8d163d903ebd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] ArtBpath",
    "data": {
        "Content-type": "multipart/alternative;\n boundary=\"Boundary_(ID_3cB7I41QIQkAMte1Uc2+lw)\"",
        "Date": "Tue, 05 Mar 2002 16:47:31 +0800",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "kevinmay@public.xm.fj.cn",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-version": "1.0",
        "Message-ID": "<005801c1c422$64134080$918842da@asshole>",
        "Precedence": "bulk",
        "Received": "from asshole ([218.66.136.145])\n by mmp2.fz.fj.cn (iPlanet Messaging Server 5.1 (built Sep  5 2001))\n with ESMTPA id <0GSH0061RRATXH@mmp2.fz.fj.cn> for libart-hackers@gnome.org;\n Tue, 05 Mar 2002 16:23:19 +0800 (CST)",
        "Return-Path": "<kevinmay@public.xm.fj.cn>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] ArtBpath",
        "To": "libart-hackers@gnome.org",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-MIMEOLE": "Produced By Microsoft MimeOLE V6.00.2462.0000",
        "X-MSMail-priority": "Normal",
        "X-Mailer": "Microsoft Outlook Express 6.00.2462.0000",
        "X-Mailman-Version": "2.0.8",
        "X-Priority": "3",
        "body": {
            "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<HTML><HEAD>\n<META http-equiv=Content-Type content=\"text/html; charset=gb2312\">\n<META content=\"MSHTML 6.00.2462.0\" name=GENERATOR>\n<STYLE></STYLE>\n</HEAD>\n<BODY bgColor=#ffffff>\n<DIV><FONT size=2>\n<DIV><FONT size=2>How to create and draw a bezier curve using ArtBpath or \nGnomeCanvasBpath on a GnomeCanvas widget?</FONT></DIV>\n<DIV><FONT size=2></FONT>&nbsp;</DIV>\n<DIV><FONT size=2>please give sample code if possible, \nthanks!</FONT></DIV></FONT></DIV></BODY></HTML>\n",
            "plain": "How to create and draw a bezier curve using ArtBpath or GnomeCanvasBpath on a GnomeCanvas widget?\n\nplease give sample code if possible, thanks!\n"
        },
        "unixfrom": "kevinmay@public.xm.fj.cn  Tue Mar  5 03:23:58 2002"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.198397,
    "updated_on": 1015318051.0,
    "uuid": "80686730d688a5a35e6c9ae170f8d163d903ebd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] ArtBpath",
    "data": {
        "Content-type": "multipart/alternative;\n boundary=\"Boundary_(ID_3cB7I41QIQkAMte1Uc2+lw)\"",
        "Date": "Tue, 05 Mar 2002 16:47:31 +0800",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "kevinmay@public.xm.fj.cn",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-version": "1.0",
        "Message-ID": "<005801c1c422$64134080$918842da@asshole>",
        "Precedence": "bulk",
        "Received": "from asshole ([218.66.136.145])\n by mmp2.fz.fj.cn (iPlanet Messaging Server 5.1 (built Sep  5 2001))\n with ESMTPA id <0GSH0061RRATXH@mmp2.fz.fj.cn> for libart-hackers@gnome.org;\n Tue, 05 Mar 2002 16:23:19 +0800 (CST)",
        "Return-Path": "<kevinmay@public.xm.fj.cn>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] ArtBpath",
        "To": "libart-hackers@gnome.org",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-MIMEOLE": "Produced By Microsoft MimeOLE V6.00.2462.0000",
        "X-MSMail-priority": "Normal",
        "X-Mailer": "Microsoft Outlook Express 6.00.2462.0000",
        "X-Mailman-Version": "2.0.8",
        "X-Priority": "3",
        "body": {
            "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<HTML><HEAD>\n<META http-equiv=Content-Type content=\"text/html; charset=gb2312\">\n<META content=\"MSHTML 6.00.2462.0\" name=GENERATOR>\n<STYLE></STYLE>\n</HEAD>\n<BODY bgColor=#ffffff>\n<DIV><FONT size=2>\n<DIV><FONT size=2>How to create and draw a bezier curve using ArtBpath or \nGnomeCanvasBpath on a GnomeCanvas widget?</FONT></DIV>\n<DIV><FONT size=2></FONT>&nbsp;</DIV>\n<DIV><FONT size=2>please give sample code if possible, \nthanks!</FONT></DIV></FONT></DIV></BODY></HTML>\n",
            "plain": "How to create and draw a bezier curve using ArtBpath or GnomeCanvasBpath on a GnomeCanvas widget?\n\nplease give sample code if possible, thanks!\n"
        },
        "unixfrom": "kevinmay@public.xm.fj.cn  Tue Mar  5 03:23:58 2002"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.204908,
    "updated_on": 1015318051.0,
    "uuid": "80686730d688a5a35e6c9ae170f8d163d903ebd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] ArtBpath",
    "data": {
        "Content-type": "multipart/alternative;\n boundary=\"Boundary_(ID_3cB7I41QIQkAMte1Uc2+lw)\"",
        "Date": "Tue, 05 Mar 2002 16:47:31 +0800",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "kevinmay@public.xm.fj.cn",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-version": "1.0",
        "Message-ID": "<005801c1c422$64134080$918842da@asshole>",
        "Precedence": "bulk",
        "Received": "from asshole ([218.66.136.145])\n by mmp2.fz.fj.cn (iPlanet Messaging Server 5.1 (built Sep  5 2001))\n with ESMTPA id <0GSH0061RRATXH@mmp2.fz.fj.cn> for libart-hackers@gnome.org;\n Tue, 05 Mar 2002 16:23:19 +0800 (CST)",
        "Return-Path": "<kevinmay@public.xm.fj.cn>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] ArtBpath",
        "To": "libart-hackers@gnome.org",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-MIMEOLE": "Produced By Microsoft MimeOLE V6.00.2462.0000",
        "X-MSMail-priority": "Normal",
        "X-Mailer": "Microsoft Outlook Express 6.00.2462.0000",
        "X-Mailman-Version": "2.0.8",
        "X-Priority": "3",
        "body": {
            "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<HTML><HEAD>\n<META http-equiv=Content-Type content=\"text/html; charset=gb2312\">\n<META content=\"MSHTML 6.00.2462.0\" name=GENERATOR>\n<STYLE></STYLE>\n</HEAD>\n<BODY bgColor=#ffffff>\n<DIV><FONT size=2>\n<DIV><FONT size=2>How to create and draw a bezier curve using ArtBpath or \nGnomeCanvasBpath on a GnomeCanvas widget?</FONT></DIV>\n<DIV><FONT size=2></FONT>&nbsp;</DIV>\n<DIV><FONT size=2>please give sample code if possible, \nthanks!</FONT></DIV></FONT></DIV></BODY></HTML>\n",
            "plain": "How to create and draw a bezier curve using ArtBpath or GnomeCanvasBpath on a GnomeCanvas widget?\n\nplease give sample code if possible, thanks!\n"
        },
        "unixfrom": "kevinmay@public.xm.fj.cn  Tue Mar  5 03:23:58 2002"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.211523,
    "updated_on": 1015318051.0,
    "uuid": "80686730d688a5a35e6c9ae170f8d163d903ebd5"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
    "data": {
        "Cc": "libart-hackers@gnome.org,\n\tGnome Hackers <gnome-hackers@gnome.org>, raph@acm.org",
        "Content-Transfer-Encoding": "7bit",
        "Content-Type": "text/plain",
        "Date": "14 Jan 2003 14:48:36 +0100",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "murrayc@t-online.de (Murray Cumming)",
        "In-Reply-To": "<1042535757.29003.72.camel@fali>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "Message-ID": "<1042552116.1201.90.camel@localhost.localdomain>",
        "Mime-Version": "1.0",
        "Organization": null,
        "Precedence": "bulk",
        "Received": "from p50803481.dip.t-dialin.net (520075295495-0001@[80.128.52.129]) by fwd07.sul.t-online.com\n\twith esmtp id 18YRcn-1bWKQqC; Tue, 14 Jan 2003 15:01:05 +0100",
        "References": "<1042535757.29003.72.camel@fali>",
        "Reply-To": "murrayc@usa.net",
        "Return-Path": "<murrayc@t-online.de>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
        "To": "Amaury Jacquot <sxpert@esitcom.org>",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailer": "Ximian Evolution 1.2.1 ",
        "X-Mailman-Version": "2.0.12",
        "X-Sender": "520075295495-0001@t-dialin.net",
        "body": {
            "plain": "On Tue, 2003-01-14 at 10:15, Amaury Jacquot wrote:\n> These files (a modified version of art_rgb_svp) allow libart to render\n> on an rgba buffer (such as the buffer in an alpha-enabled gdk-pixbuf) so\n> as to allow to pre-render several drawing layers .in an application\n> where the gnome-canvas would be too slow (zillions of points, see\n> http://sxpert.esitcom.org/projects/mapeditor)\n\nThe libart maintainer would probably prefer a patch, and would probably\nprefer that patch to go in bugzilla.gnome.org, or to some libart mailing\nlist.\n\n-- \nMurray Cumming\nmurray@usa.net\nwww.murrayc.com\n\n"
        },
        "unixfrom": "murrayc@t-online.de  Tue Jan 14 09:01:17 2003"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.238181,
    "updated_on": 1042552116.0,
    "uuid": "3a1d96e146ede59113a6c65c52e1e60e0035ae17"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
    "data": {
        "Cc": "libart-hackers@gnome.org, <gnome-hackers@gnome.org>,\n\t<raph@acm.org>",
        "Content-Type": "TEXT/PLAIN; charset=US-ASCII",
        "Date": "Tue, 14 Jan 2003 09:42:39 -0500 (EST)",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Alexander Larsson <alexl@redhat.com>",
        "In-Reply-To": "<1042535757.29003.72.camel@fali>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-Version": "1.0",
        "Message-ID": "<Pine.LNX.4.44.0301140941470.27230-100000@devserv.devel.redhat.com>",
        "Precedence": "bulk",
        "Received": "from localhost (alexl@localhost)\n\tby devserv.devel.redhat.com (8.11.6/8.11.0) with ESMTP id h0EEgd625623;\n\tTue, 14 Jan 2003 09:42:39 -0500",
        "Return-Path": "<alexl@redhat.com>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
        "To": "Amaury Jacquot <sxpert@esitcom.org>",
        "X-Authentication-Warning": "devserv.devel.redhat.com: alexl owned process doing -bs",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0.12",
        "X-X-Sender": "alexl@devserv.devel.redhat.com",
        "body": {
            "plain": "On 14 Jan 2003, Amaury Jacquot wrote:\n\n> These files (a modified version of art_rgb_svp) allow libart to render\n> on an rgba buffer (such as the buffer in an alpha-enabled gdk-pixbuf) so\n> as to allow to pre-render several drawing layers .in an application\n> where the gnome-canvas would be too slow (zillions of points, see\n> http://sxpert.esitcom.org/projects/mapeditor)\n\nYou can already do this with the art_render.h interface. This is the \nprefered interface since its extensible instead of having to duplicode \ncode all over like you just had to.\n\n-- \n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n Alexander Larsson                                            Red Hat, Inc \n                   alexl@redhat.com    alla@lysator.liu.se \nHe's a world-famous guitar-strumming cyborg plagued by the memory of his \nfamily's brutal murder. She's a green-fingered antique-collecting advertising \nexecutive with the power to see death. They fight crime! \n\n"
        },
        "unixfrom": "alexl@redhat.com  Tue Jan 14 09:42:42 2003"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.241297,
    "updated_on": 1042555359.0,
    "uuid": "109e03fa685744a5ef3b89a72c4a06f290a99d11"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] rendering svps on a pixel buffer that has an alpha channel",
    "data": {
        "Cc": "gnome-hackers@gnome.org, raph@acm.org",
        "Content-Type": "multipart/mixed; boundary=\"=-WNfSv/DRYgy9USsdlJKs\"",
        "Date": "14 Jan 2003 10:15:58 +0100",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Amaury Jacquot <sxpert@esitcom.org>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "Message-ID": "<1042535757.29003.72.camel@fali>",
        "Mime-Version": "1.0",
        "Organization": null,
        "Precedence": "bulk",
        "Received": "from fali.imag.fr (fali.imag.fr [129.88.31.52])\n\tby moulinette.imag.fr (8.11.6/8.11.6/ImagV2) with ESMTP id h0E9F4L11111;\n\tTue, 14 Jan 2003 10:15:04 +0100",
        "Return-Path": "<sxpert@esitcom.org>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] rendering svps on a pixel buffer that has an alpha channel",
        "To": "libart-hackers@gnome.org",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailer": "Ximian Evolution 1.2.0 ",
        "X-Mailman-Version": "2.0.12",
        "body": {
            "plain": "These files (a modified version of art_rgb_svp) allow libart to render\non an rgba buffer (such as the buffer in an alpha-enabled gdk-pixbuf) so\nas to allow to pre-render several drawing layers .in an application\nwhere the gnome-canvas would be too slow (zillions of points, see\nhttp://sxpert.esitcom.org/projects/mapeditor)\n\nsincerely\n\nAmaury\n",
            "x-c": "/* Libart_LGPL - library of basic graphic primitives\n * Copyright (C) 1998 Raph Levien\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n *\n * this was adapted for RGBA buffers from art_rgb_svp.c by Amaury Jacquot <sxpert@esitcom.org>\n */\n\n/* Render a sorted vector path into an RGB buffer. */\n\n#include \"config.h\"\n#include \"art_rgba_svp.h\"\n\n#include \"art_svp.h\"\n#include \"art_svp_render_aa.h\"\n#include \"art_rgba.h\"\n\ntypedef struct _ArtRgbSVPData ArtRgbSVPData;\ntypedef struct _ArtRgbSVPAlphaData ArtRgbSVPAlphaData;\n\nstruct _ArtRgbSVPData {\n  art_u32 rgbtab[256];\n  art_u8 *buf;\n  int rowstride;\n  int x0, x1;\n};\n\nstruct _ArtRgbSVPAlphaData {\n  int alphatab[256];\n  art_u8 r, g, b, alpha;\n  art_u8 *buf;\n  int rowstride;\n  int x0, x1;\n};\n\nstatic void\nart_rgba_svp_callback (void *callback_data, int y,\n\t\t      int start, ArtSVPRenderAAStep *steps, int n_steps)\n{\n  ArtRgbSVPData *data = (ArtRgbSVPData *)callback_data;\n  art_u8 *linebuf;\n  int run_x0, run_x1;\n  art_u32 running_sum = start;\n  art_u32 rgb;\n  int x0, x1;\n  int k;\n\n  linebuf = data->buf;\n  x0 = data->x0;\n  x1 = data->x1;\n\n  if (n_steps > 0)\n    {\n      run_x1 = steps[0].x;\n      if (run_x1 > x0)\n\t{\n\t  rgb = data->rgbtab[(running_sum >> 16) & 0xff];\n\t  art_rgba_fill_run (linebuf,\n\t\t\t     rgb >> 16, (rgb >> 8) & 0xff, rgb & 0xff,\n\t\t\t    run_x1 - x0);\n\t}\n\n      for (k = 0; k < n_steps - 1; k++)\n\t{\n\t  running_sum += steps[k].delta;\n\t  run_x0 = run_x1;\n\t  run_x1 = steps[k + 1].x;\n\t  if (run_x1 > run_x0)\n\t    {\n\t      rgb = data->rgbtab[(running_sum >> 16) & 0xff];\n\t      art_rgba_fill_run (linebuf + (run_x0 - x0) * 3,\n\t\t\t\trgb >> 16, (rgb >> 8) & 0xff, rgb & 0xff,\n\t\t\t\trun_x1 - run_x0);\n\t    }\n\t}\n      running_sum += steps[k].delta;\n      if (x1 > run_x1)\n\t{\n\t  rgb = data->rgbtab[(running_sum >> 16) & 0xff];\n\t  art_rgba_fill_run (linebuf + (run_x1 - x0) * 3,\n\t\t\t    rgb >> 16, (rgb >> 8) & 0xff, rgb & 0xff,\n\t\t\t    x1 - run_x1);\n\t}\n    }\n  else\n    {\n      rgb = data->rgbtab[(running_sum >> 16) & 0xff];\n      art_rgba_fill_run (linebuf,\n\t\t\t rgb >> 16, (rgb >> 8) & 0xff, rgb & 0xff,\n\t\t\tx1 - x0);\n    }\n\n  data->buf += data->rowstride;\n}\n\n/* Render the vector path into the RGB buffer. */\n\n/**\n * art_rgb_svp_aa: Render sorted vector path into RGB buffer.\n * @svp: The source sorted vector path.\n * @x0: Left coordinate of destination rectangle.\n * @y0: Top coordinate of destination rectangle.\n * @x1: Right coordinate of destination rectangle.\n * @y1: Bottom coordinate of destination rectangle.\n * @fg_color: Foreground color in 0xRRGGBB format.\n * @bg_color: Background color in 0xRRGGBB format.\n * @buf: Destination RGB buffer.\n * @rowstride: Rowstride of @buf buffer.\n * @alphagamma: #ArtAlphaGamma for gamma-correcting the rendering.\n *\n * Renders the shape specified with @svp into the @buf RGB buffer.\n * @x1 - @x0 specifies the width, and @y1 - @y0 specifies the height,\n * of the rectangle rendered. The new pixels are stored starting at\n * the first byte of @buf. Thus, the @x0 and @y0 parameters specify\n * an offset within @svp, and may be tweaked as a way of doing\n * integer-pixel translations without fiddling with @svp itself.\n *\n * The @fg_color and @bg_color arguments specify the opaque colors to\n * be used for rendering. For pixels of entirely 0 winding-number,\n * @bg_color is used. For pixels of entirely 1 winding number,\n * @fg_color is used. In between, the color is interpolated based on\n * the fraction of the pixel with a winding number of 1. If\n * @alphagamma is NULL, then linear interpolation (in pixel counts) is\n * the default. Otherwise, the interpolation is as specified by\n * @alphagamma.\n **/\nvoid\nart_rgba_svp_aa (const ArtSVP *svp,\n\t\tint x0, int y0, int x1, int y1,\n\t\tart_u32 fg_color, art_u32 bg_color,\n\t\tart_u8 *buf, int rowstride,\n\t\tArtAlphaGamma *alphagamma)\n{\n  ArtRgbSVPData data;\n\n  int r_fg, g_fg, b_fg;\n  int r_bg, g_bg, b_bg;\n  int r, g, b;\n  int dr, dg, db;\n  int i;\n\n  if (alphagamma == NULL)\n    {\n      r_fg = fg_color >> 16;\n      g_fg = (fg_color >> 8) & 0xff;\n      b_fg = fg_color & 0xff;\n\n      r_bg = bg_color >> 16;\n      g_bg = (bg_color >> 8) & 0xff;\n      b_bg = bg_color & 0xff;\n\n      r = (r_bg << 16) + 0x8000;\n      g = (g_bg << 16) + 0x8000;\n      b = (b_bg << 16) + 0x8000;\n      dr = ((r_fg - r_bg) << 16) / 255;\n      dg = ((g_fg - g_bg) << 16) / 255;\n      db = ((b_fg - b_bg) << 16) / 255;\n\n      for (i = 0; i < 256; i++)\n\t{\n\t  data.rgbtab[i] = (r & 0xff0000) | ((g & 0xff0000) >> 8) | (b >> 16);\n\t  r += dr;\n\t  g += dg;\n\t  b += db;\n\t}\n    }\n  else\n    {\n      int *table;\n      art_u8 *invtab;\n\n      table = alphagamma->table;\n\n      r_fg = table[fg_color >> 16];\n      g_fg = table[(fg_color >> 8) & 0xff];\n      b_fg = table[fg_color & 0xff];\n\n      r_bg = table[bg_color >> 16];\n      g_bg = table[(bg_color >> 8) & 0xff];\n      b_bg = table[bg_color & 0xff];\n\n      r = (r_bg << 16) + 0x8000;\n      g = (g_bg << 16) + 0x8000;\n      b = (b_bg << 16) + 0x8000;\n      dr = ((r_fg - r_bg) << 16) / 255;\n      dg = ((g_fg - g_bg) << 16) / 255;\n      db = ((b_fg - b_bg) << 16) / 255;\n\n      invtab = alphagamma->invtable;\n      for (i = 0; i < 256; i++)\n\t{\n\t  data.rgbtab[i] = (invtab[r >> 16] << 16) |\n\t    (invtab[g >> 16] << 8) |\n\t    invtab[b >> 16];\n\t  r += dr;\n\t  g += dg;\n\t  b += db;\n\t}\n    }\n  data.buf = buf;\n  data.rowstride = rowstride;\n  data.x0 = x0;\n  data.x1 = x1;\n  art_svp_render_aa (svp, x0, y0, x1, y1, art_rgba_svp_callback, &data);\n}\n\nstatic void\nart_rgba_svp_alpha_callback (void *callback_data, int y,\n\t\t\t    int start, ArtSVPRenderAAStep *steps, int n_steps)\n{\n  ArtRgbSVPAlphaData *data = (ArtRgbSVPAlphaData *)callback_data;\n  art_u8 *linebuf;\n  int run_x0, run_x1;\n  art_u32 running_sum = start;\n  int x0, x1;\n  int k;\n  art_u8 r, g, b;\n  int *alphatab;\n  int alpha;\n\n  linebuf = data->buf;\n  x0 = data->x0;\n  x1 = data->x1;\n\n  r = data->r;\n  g = data->g;\n  b = data->b;\n  alphatab = data->alphatab;\n\n  if (n_steps > 0)\n    {\n      run_x1 = steps[0].x;\n      if (run_x1 > x0)\n\t{\n\t  alpha = (running_sum >> 16) & 0xff;\n\t  if (alpha)\n\t    art_rgba_run_alpha (linebuf,\n\t\t\t\tr, g, b, alphatab[alpha],\n\t\t\t\trun_x1 - x0);\n\t}\n\n      for (k = 0; k < n_steps - 1; k++)\n\t{\n\t  running_sum += steps[k].delta;\n\t  run_x0 = run_x1;\n\t  run_x1 = steps[k + 1].x;\n\t  if (run_x1 > run_x0)\n\t    {\n\t      alpha = (running_sum >> 16) & 0xff;\n\t      if (alpha)\n\t\tart_rgba_run_alpha (linebuf + (run_x0 - x0) * 4,\n\t\t\t\t   r, g, b, alphatab[alpha],\n\t\t\t\t   run_x1 - run_x0);\n\t    }\n\t}\n      running_sum += steps[k].delta;\n      if (x1 > run_x1)\n\t{\n\t  alpha = (running_sum >> 16) & 0xff;\n\t  if (alpha)\n\t    art_rgba_run_alpha (linebuf + (run_x1 - x0) * 4,\n\t\t\t       r, g, b, alphatab[alpha],\n\t\t\t       x1 - run_x1);\n\t}\n    }\n  else\n    {\n      alpha = (running_sum >> 16) & 0xff;\n      if (alpha)\n\tart_rgba_run_alpha (linebuf,\n\t\t\t   r, g, b, alphatab[alpha],\n\t\t\t   x1 - x0);\n    }\n\n  data->buf += data->rowstride;\n}\n\nstatic void\nart_rgba_svp_alpha_opaque_callback (void *callback_data, int y,\n\t\t\t\t   int start,\n\t\t\t\t   ArtSVPRenderAAStep *steps, int n_steps)\n{\n  ArtRgbSVPAlphaData *data = (ArtRgbSVPAlphaData *)callback_data;\n  art_u8 *linebuf;\n  int run_x0, run_x1;\n  art_u32 running_sum = start;\n  int x0, x1;\n  int k;\n  art_u8 r, g, b;\n  int *alphatab;\n  int alpha;\n\n  linebuf = data->buf;\n  x0 = data->x0;\n  x1 = data->x1;\n\n  r = data->r;\n  g = data->g;\n  b = data->b;\n  alphatab = data->alphatab;\n\n  if (n_steps > 0)\n    {\n      run_x1 = steps[0].x;\n      if (run_x1 > x0)\n\t{\n\t  alpha = running_sum >> 16;\n\t  if (alpha)\n\t    {\n\t      if (alpha >= 255)\n\t\tart_rgba_fill_run (linebuf,\n\t\t\t\t   r, g, b,\n\t\t\t\t   run_x1 - x0);\n\t      else\n\t\tart_rgba_run_alpha (linebuf,\n\t\t\t\t   r, g, b, alphatab[alpha],\n\t\t\t\t   run_x1 - x0);\n\t    }\n\t}\n\n      for (k = 0; k < n_steps - 1; k++)\n\t{\n\t  running_sum += steps[k].delta;\n\t  run_x0 = run_x1;\n\t  run_x1 = steps[k + 1].x;\n\t  if (run_x1 > run_x0)\n\t    {\n\t      alpha = running_sum >> 16;\n\t      if (alpha)\n\t\t{\n\t\t  if (alpha >= 255)\n\t\t    art_rgba_fill_run (linebuf + (run_x0 - x0) * 3,\n\t\t\t\t       r, g, b,\n\t\t\t\t       run_x1 - run_x0);\n\t\t  else\n\t\t    art_rgba_run_alpha (linebuf + (run_x0 - x0) * 3,\n\t\t\t\t       r, g, b, alphatab[alpha],\n\t\t\t\t       run_x1 - run_x0);\n\t\t}\n\t    }\n\t}\n      running_sum += steps[k].delta;\n      if (x1 > run_x1)\n\t{\n\t  alpha = running_sum >> 16;\n\t  if (alpha)\n\t    {\n\t      if (alpha >= 255)\n\t\tart_rgba_fill_run (linebuf + (run_x1 - x0) * 3,\n\t\t\t\t   r, g, b, \n\t\t\t\t   x1 - run_x1);\n\t      else\n\t\tart_rgba_run_alpha (linebuf + (run_x1 - x0) * 3,\n\t\t\t\t    r, g, b, alphatab[alpha],\n\t\t\t\t    x1 - run_x1);\n\t    }\n\t}\n    }\n  else\n    {\n      alpha = running_sum >> 16;\n      if (alpha)\n\t{\n\t  if (alpha >= 255)\n\t    art_rgba_fill_run (linebuf,\n\t\t\t       r, g, b, \n\t\t\t       x1 - x0);\n\t  else\n\t    art_rgba_run_alpha (linebuf,\n\t\t\t\tr, g, b, alphatab[alpha],\n\t\t\t\tx1 - x0);\n\t}\n    }\n\n  data->buf += data->rowstride;\n}\n\n/**\n * art_rgb_svp_alpha: Alpha-composite sorted vector path over RGB buffer.\n * @svp: The source sorted vector path.\n * @x0: Left coordinate of destination rectangle.\n * @y0: Top coordinate of destination rectangle.\n * @x1: Right coordinate of destination rectangle.\n * @y1: Bottom coordinate of destination rectangle.\n * @rgba: Color in 0xRRGGBBAA format.\n * @buf: Destination RGB buffer.\n * @rowstride: Rowstride of @buf buffer.\n * @alphagamma: #ArtAlphaGamma for gamma-correcting the compositing.\n *\n * Renders the shape specified with @svp over the @buf RGB buffer.\n * @x1 - @x0 specifies the width, and @y1 - @y0 specifies the height,\n * of the rectangle rendered. The new pixels are stored starting at\n * the first byte of @buf. Thus, the @x0 and @y0 parameters specify\n * an offset within @svp, and may be tweaked as a way of doing\n * integer-pixel translations without fiddling with @svp itself.\n *\n * The @rgba argument specifies the color for the rendering. Pixels of\n * entirely 0 winding number are left untouched. Pixels of entirely\n * 1 winding number have the color @rgba composited over them (ie,\n * are replaced by the red, green, blue components of @rgba if the alpha\n * component is 0xff). Pixels of intermediate coverage are interpolated\n * according to the rule in @alphagamma, or default to linear if\n * @alphagamma is NULL.\n **/\nvoid\nart_rgba_svp_alpha (const ArtSVP *svp,\n\t\t   int x0, int y0, int x1, int y1,\n\t\t   art_u32 rgba,\n\t\t   art_u8 *buf, int rowstride,\n\t\t   ArtAlphaGamma *alphagamma)\n{\n  ArtRgbSVPAlphaData data;\n  int r, g, b, alpha;\n  int i;\n  int a, da;\n\n  r = rgba >> 24;\n  g = (rgba >> 16) & 0xff;\n  b = (rgba >> 8) & 0xff;\n  alpha = rgba & 0xff;\n\n  data.r = r;\n  data.g = g;\n  data.b = b;\n  data.alpha = alpha;\n\n  a = 0x8000;\n  da = (alpha * 66051 + 0x80) >> 8; /* 66051 equals 2 ^ 32 / (255 * 255) */\n\n  for (i = 0; i < 256; i++)\n    {\n      data.alphatab[i] = a >> 16;\n      a += da;\n    }\n\n  data.buf = buf;\n  data.rowstride = rowstride;\n  data.x0 = x0;\n  data.x1 = x1;\n  if (alpha == 255)\n    art_svp_render_aa (svp, x0, y0, x1, y1, art_rgba_svp_alpha_opaque_callback,\n\t\t       &data);\n  else\n    art_svp_render_aa (svp, x0, y0, x1, y1, art_rgba_svp_alpha_callback, &data);\n}\n\n",
            "x-c-header": "/* Libart_LGPL - library of basic graphic primitives\n * Copyright (C) 1998 Raph Levien\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n *\n * this was adapted for RGBA buffers from art_rgb_svp.h by Amaury Jacquot <sxpert@esitcom.org>\n */\n\n#ifndef __ART_RGBA_SVP_H__\n#define __ART_RGBA_SVP_H__\n\n/* Render a sorted vector path into an RGB buffer. */\n\n#ifdef LIBART_COMPILATION\n#include \"art_alphagamma.h\"\n#include \"art_svp.h\"\n#else\n#include <libart_lgpl/art_alphagamma.h>\n#include <libart_lgpl/art_svp.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nvoid\nart_rgba_svp_aa (const ArtSVP *svp,\n\t\tint x0, int y0, int x1, int y1,\n\t\tart_u32 fg_color, art_u32 bg_color,\n\t\tart_u8 *buf, int rowstride,\n\t\tArtAlphaGamma *alphagamma);\n\nvoid\nart_rgba_svp_alpha (const ArtSVP *svp,\n\t\t   int x0, int y0, int x1, int y1,\n\t\t   art_u32 rgba,\n\t\t   art_u8 *buf, int rowstride,\n\t\t   ArtAlphaGamma *alphagamma);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __ART_RGBA_SVP_H__ */\n"
        },
        "unixfrom": "sxpert@esitcom.org  Tue Jan 14 04:15:08 2003"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.249211,
    "updated_on": 1042535758.0,
    "uuid": "543aac58e984df602a57adf8924cbf4afaf49fb9"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
    "data": {
        "Cc": "libart-hackers@gnome.org,\n\tGnome Hackers <gnome-hackers@gnome.org>, raph@acm.org",
        "Content-Transfer-Encoding": "7bit",
        "Content-Type": "text/plain",
        "Date": "14 Jan 2003 14:48:36 +0100",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "murrayc@t-online.de (Murray Cumming)",
        "In-Reply-To": "<1042535757.29003.72.camel@fali>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "Message-ID": "<1042552116.1201.90.camel@localhost.localdomain>",
        "Mime-Version": "1.0",
        "Organization": null,
        "Precedence": "bulk",
        "Received": "from p50803481.dip.t-dialin.net (520075295495-0001@[80.128.52.129]) by fwd07.sul.t-online.com\n\twith esmtp id 18YRcn-1bWKQqC; Tue, 14 Jan 2003 15:01:05 +0100",
        "References": "<1042535757.29003.72.camel@fali>",
        "Reply-To": "murrayc@usa.net",
        "Return-Path": "<murrayc@t-online.de>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
        "To": "Amaury Jacquot <sxpert@esitcom.org>",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailer": "Ximian Evolution 1.2.1 ",
        "X-Mailman-Version": "2.0.12",
        "X-Sender": "520075295495-0001@t-dialin.net",
        "body": {
            "plain": "On Tue, 2003-01-14 at 10:15, Amaury Jacquot wrote:\n> These files (a modified version of art_rgb_svp) allow libart to render\n> on an rgba buffer (such as the buffer in an alpha-enabled gdk-pixbuf) so\n> as to allow to pre-render several drawing layers .in an application\n> where the gnome-canvas would be too slow (zillions of points, see\n> http://sxpert.esitcom.org/projects/mapeditor)\n\nThe libart maintainer would probably prefer a patch, and would probably\nprefer that patch to go in bugzilla.gnome.org, or to some libart mailing\nlist.\n\n-- \nMurray Cumming\nmurray@usa.net\nwww.murrayc.com\n\n"
        },
        "unixfrom": "murrayc@t-online.de  Tue Jan 14 09:01:17 2003"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.252518,
    "updated_on": 1042552116.0,
    "uuid": "3a1d96e146ede59113a6c65c52e1e60e0035ae17"
},
{
    "backend_name": "Pipermail",
    "backend_version": "0.1.0",
    "context": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
    "data": {
        "Cc": "libart-hackers@gnome.org, <gnome-hackers@gnome.org>,\n\t<raph@acm.org>",
        "Content-Type": "TEXT/PLAIN; charset=US-ASCII",
        "Date": "Tue, 14 Jan 2003 09:42:39 -0500 (EST)",
        "Delivered-To": "libart-hackers@gnome.org",
        "Errors-To": "libart-hackers-admin@gnome.org",
        "From": "Alexander Larsson <alexl@redhat.com>",
        "In-Reply-To": "<1042535757.29003.72.camel@fali>",
        "List-Archive": "<http://mail.gnome.org/archives/libart-hackers/>",
        "List-Help": "<mailto:libart-hackers-request@gnome.org?subject=help>",
        "List-Id": "Development of the Libart 2D imaging library <libart-hackers.gnome.org>",
        "List-Post": "<mailto:libart-hackers@gnome.org>",
        "List-Subscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=subscribe>",
        "List-Unsubscribe": "<http://mail.gnome.org/mailman/listinfo/libart-hackers>,\n\t<mailto:libart-hackers-request@gnome.org?subject=unsubscribe>",
        "MIME-Version": "1.0",
        "Message-ID": "<Pine.LNX.4.44.0301140941470.27230-100000@devserv.devel.redhat.com>",
        "Precedence": "bulk",
        "Received": "from localhost (alexl@localhost)\n\tby devserv.devel.redhat.com (8.11.6/8.11.0) with ESMTP id h0EEgd625623;\n\tTue, 14 Jan 2003 09:42:39 -0500",
        "Return-Path": "<alexl@redhat.com>",
        "Sender": "libart-hackers-admin@gnome.org",
        "Subject": "[ART_HACK] Re: rendering svps on a pixel buffer that has an alpha channel",
        "To": "Amaury Jacquot <sxpert@esitcom.org>",
        "X-Authentication-Warning": "devserv.devel.redhat.com: alexl owned process doing -bs",
        "X-BeenThere": "libart-hackers@gnome.org",
        "X-Loop": "libart-hackers@gnome.org",
        "X-Mailman-Version": "2.0.12",
        "X-X-Sender": "alexl@devserv.devel.redhat.com",
        "body": {
            "plain": "On 14 Jan 2003, Amaury Jacquot wrote:\n\n> These files (a modified version of art_rgb_svp) allow libart to render\n> on an rgba buffer (such as the buffer in an alpha-enabled gdk-pixbuf) so\n> as to allow to pre-render several drawing layers .in an application\n> where the gnome-canvas would be too slow (zillions of points, see\n> http://sxpert.esitcom.org/projects/mapeditor)\n\nYou can already do this with the art_render.h interface. This is the \nprefered interface since its extensible instead of having to duplicode \ncode all over like you just had to.\n\n-- \n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n Alexander Larsson                                            Red Hat, Inc \n                   alexl@redhat.com    alla@lysator.liu.se \nHe's a world-famous guitar-strumming cyborg plagued by the memory of his \nfamily's brutal murder. She's a green-fingered antique-collecting advertising \nexecutive with the power to see death. They fight crime! \n\n"
        },
        "unixfrom": "alexl@redhat.com  Tue Jan 14 09:42:42 2003"
    },
    "data_source": "Mbox",
    "origin": "https://mail.gnome.org/archives/libart-hackers/",
    "perceval_version": "0.2.0",
    "timestamp": 1469618584.255637,
    "updated_on": 1042555359.0,
    "uuid": "109e03fa685744a5ef3b89a72c4a06f290a99d11"
}
]